# 智能消息合并 (Smart Message Merging) 示例

## 背景

在现代 LLM 应用中，特别是涉及工具使用（函数调用）的应用，管理消息历史至关重要。一种常见的模式是 LLM 生成一个“工具调用”消息，随后是工具执行结果。有时，我们希望 **更新** 之前的消息（例如，将“思考中...”占位符替换为最终答案），而不是追加一条新消息。标准的列表追加无法满足这一需求。**AddMessages Reducer** 提供了智能的合并逻辑。

## 功能特性

*   **基于 ID 的去重**: 如果新消息与现有消息具有相同的 ID，它会更新（覆盖）现有消息，而不是追加。
*   **自动追加**: 没有 ID（或具有新 ID）的消息会自动追加到列表末尾。
*   **灵活性**: 既支持 `llms.MessageContent`（标准），也支持自定义的基于 Map 的消息结构。

## 实现原理

`graph/add_messages.go` 中的 `AddMessages` 函数实现了 Reducer 逻辑：
1.  遍历新消息。
2.  对于每条消息，尝试提取 ID（通过 `MessageWithID` 接口、Map 键 "id" 或结构体字段 "ID"）。
3.  如果找到 ID 且与当前状态列表中的现有消息匹配，则在原索引处替换现有消息。
4.  否则，追加新消息。

## 代码导读

在 `main.go` 中：

1.  **图设置**:
    ```go
    g := graph.NewMessagesStateGraph()
    ```
    这个辅助函数创建了一个图，其中 "messages" 键预配置为使用 `AddMessages`。

2.  **AI Response 节点**:
    返回一条 `id: "msg_123"` 且内容为 "Thinking..." 的消息。

3.  **AI Update 节点**:
    返回一条具有 **相同** `id: "msg_123"` 但内容为 "Hello..." 的消息。

4.  **结果**:
    由于 ID 匹配，最终历史记录中只包含 **一条** AI 消息（更新后的那条），而不是两条。

## 如何运行

```bash
go run main.go
```
